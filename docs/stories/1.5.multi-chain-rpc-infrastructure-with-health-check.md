# Story 1.5: Multi-Chain RPC Infrastructure with Health Check

## Status
Ready for Review

## Story
**As a** developer,
**I want** to implement efficient batched RPC calls with a working health check system,
**so that** I can validate RPC connectivity and establish the data fetching foundation.

## Acceptance Criteria
1. RPC provider configuration with Alchemy/Infura primary and fallback endpoints
2. Batched RPC call system with example batch operation (multiple eth_getBalance calls)
3. Redis caching layer for RPC responses with configurable TTL
4. Rate limiting protection with exponential backoff and queue management
5. Chain-specific error handling and failover mechanisms
6. Health check endpoint that tests RPC connectivity to all three chains

## Tasks / Subtasks
- [x] Configure RPC Provider Infrastructure (AC: 1)
  - [x] Set up Alchemy provider configuration for Ethereum, Arbitrum, and Avalanche
  - [x] Configure Infura as fallback provider with proper authentication
  - [x] Create provider configuration in `packages/web3/src/rpc/providers.ts`
  - [x] Set up environment variables for API keys in `.env.example`
- [x] Implement RPC Batch Manager Service (AC: 2)
  - [x] Create `apps/api/src/services/RpcBatchManager.ts` service class
  - [x] Implement `batchCall()` method for aggregating multiple RPC requests
  - [x] Add example batch operation for multiple `eth_getBalance` calls
  - [x] Ensure BigInt handling for all numeric blockchain values
- [x] Set Up Redis Caching Layer (AC: 3)
  - [x] Configure Redis client connection in `apps/api/src/db/redis.ts`
  - [x] Implement cache key generation strategy for RPC responses
  - [x] Add configurable TTL settings per cache type (balances: 30s, metadata: 1h)
  - [x] Create `getCachedData()` and `setCachedData()` methods
- [x] Implement Rate Limiting and Queue Management (AC: 4)
  - [x] Add rate limiting middleware using `@fastify/rate-limit`
  - [x] Implement exponential backoff retry logic in RPC Batch Manager
  - [x] Create request queue with configurable concurrency limits
  - [x] Add monitoring for rate limit violations and queue depth
- [x] Build Chain-Specific Error Handling (AC: 5)
  - [x] Create error classification system for RPC errors
  - [x] Implement automatic failover from Alchemy to Infura on errors
  - [x] Add chain-specific error recovery strategies
  - [x] Log all provider switches and error patterns for monitoring
- [x] Create Health Check Endpoint (AC: 6)
  - [x] Implement `/health` endpoint in Fastify server
  - [x] Add RPC connectivity tests for all three chains
  - [x] Include Redis connection health check
  - [x] Return detailed service status with response times
- [x] Write Comprehensive Tests (Testing Requirements)
  - [x] Unit tests for RPC Batch Manager service
  - [x] Integration tests for provider failover scenarios
  - [x] Tests for cache hit/miss scenarios
  - [x] E2E test for health check endpoint
  - [x] Performance tests for batch operations

## Dev Notes

### Previous Story Insights
From Story 1.2 completion:
- Wagmi v2 configuration is set up with chain definitions for Ethereum (1), Arbitrum (42161), and Avalanche (43114)
- Wallet connection infrastructure is established and can be leveraged for testing RPC calls
- Mock portfolio data structure is defined and can be replaced with real RPC data

### RPC Provider Configuration
[Source: architecture/external-apis.md#alchemy-api]
- **Alchemy API**: Primary RPC provider with 300 compute units/second (Growth tier)
- **Base URLs**: Chain-specific endpoints (eth-mainnet, arb-mainnet, avax-mainnet)
- **Authentication**: API Key in headers
- **Enhanced APIs**: Use `getTokenBalances` and `getTokenMetadata` for efficiency

[Source: architecture/external-apis.md#infura-api]
- **Infura API**: Fallback provider with 100,000 requests/day (Core tier)
- **Purpose**: Ensuring 99.5% uptime through provider redundancy
- **Authentication**: Project ID and secret

### Service Implementation Location
[Source: architecture/unified-project-structure.md#backend-organization]
- **RPC Batch Manager**: `apps/api/src/services/RpcBatchManager.ts`
- **Provider Adapters**: `apps/api/src/adapters/blockchain/AlchemyProvider.ts`, `InfuraProvider.ts`
- **Cache Client**: `apps/api/src/db/redis.ts`
- **Health Check**: Add to existing `apps/api/src/server.ts`

### Technology Stack Requirements
[Source: architecture/tech-stack.md#technology-stack-table]
- **Backend Framework**: Fastify 4.x for high-performance
- **Cache**: Redis 7.x via Redis Cloud for RPC response caching
- **Backend Language**: Node.js 20 LTS
- **Database**: PostgreSQL 15+ via Supabase for persistence

### RPC Batch Manager Component Specification
[Source: architecture/components.md#rpc-batch-manager]
**Key Interfaces**:
- `batchCall(requests: RPCRequest[]): Promise<RPCResponse[]>` - Execute batched RPC requests
- `getCachedData(key: string): Promise<CachedData | null>` - Retrieve cached blockchain data
- `invalidateCache(pattern: string): Promise<void>` - Cache invalidation for real-time updates

**Dependencies**: Redis Cache, RPC Providers (Alchemy/Infura), Chain Configuration Service

### Server Configuration Pattern
[Source: architecture/backend-architecture.md#server-template]
```typescript
// Health check endpoint pattern already defined in server.ts
server.get('/health', async (request, reply) => {
  const health = {
    status: 'healthy',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    services: {
      database: await checkDatabaseHealth(),
      redis: await checkRedisHealth(),
      rpc: await checkRpcHealth() // Add this new check
    }
  };
  // Return 200 if all healthy, 503 if any service is down
});
```

### Error Handling Strategy
[Source: architecture/external-apis.md#error-handling-fallback-strategy]
**RPC Provider Fallback Order**:
1. Primary: Alchemy API with enhanced features
2. Secondary: Infura API for redundancy
3. Tertiary: Additional providers as needed

### Coding Standards
[Source: architecture/coding-standards.md#critical-fullstack-rules]
- **BigInt Precision**: Always use BigInt for financial calculations, never JavaScript numbers
- **RPC Batching**: Group blockchain calls through RPC Batch Manager, never direct calls
- **Environment Variables**: Access only through config objects, never process.env directly
- **Error Handling**: All API routes must use the standard error handler

### Testing Requirements
[Source: architecture/testing-strategy.md#backend-tests]
**Test Organization**:
- Unit tests: `apps/api/tests/unit/services/RpcBatchManager.test.ts`
- Integration tests: `apps/api/tests/integration/rpc-failover.test.ts`
- Test fixtures: `apps/api/tests/fixtures/rpc-responses.ts`

**Testing Framework**: Vitest for all backend tests with Supertest for API testing

### Environment Variables Required
```bash
# RPC Providers
ALCHEMY_API_KEY=your_alchemy_key
INFURA_PROJECT_ID=your_infura_project_id
INFURA_PROJECT_SECRET=your_infura_secret

# Redis Configuration
REDIS_URL=redis://localhost:6379
REDIS_PASSWORD=optional_password

# Rate Limiting
RPC_RATE_LIMIT_MAX=100
RPC_RATE_LIMIT_WINDOW=60000
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-08 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
claude-opus-4-1-20250805

### Debug Log References
- RPC provider configuration implemented with chain-specific URLs
- Enhanced batch manager with exponential backoff and queue management
- Redis caching layer with configurable TTL settings
- Comprehensive error handling and failover mechanisms
- Health check endpoint with detailed service monitoring

### Completion Notes List
- ✅ Configured RPC providers for Ethereum, Arbitrum, and Avalanche with Alchemy primary and Infura fallback
- ✅ Implemented batched RPC call system with example multi-balance operations
- ✅ Set up Redis caching with chain-specific cache keys and TTL configuration
- ✅ Added rate limiting middleware with @fastify/rate-limit and exponential backoff retry logic
- ✅ Built chain-specific error classification and automatic provider failover
- ✅ Created comprehensive health check endpoint testing all RPC connectivity
- ✅ Wrote unit tests, integration tests, and E2E tests with 80%+ coverage targets

### File List
- `packages/web3/src/rpc/providers.ts` - RPC provider management with failover
- `packages/shared/src/constants/chains.ts` - Chain configuration constants  
- `apps/api/src/services/RpcBatchManager.ts` - Core batch RPC service
- `apps/api/src/services/CachedRpcBatchManager.ts` - Cached RPC operations
- `apps/api/src/services/EnhancedRpcBatchManager.ts` - Full featured manager with queues
- `apps/api/src/services/RpcErrorHandler.ts` - Error classification and recovery
- `apps/api/src/db/redis.ts` - Redis caching implementation
- `apps/api/src/middleware/rateLimit.ts` - Rate limiting middleware
- `apps/api/src/server.ts` - Main Fastify server with health check endpoint
- `apps/api/.env.example` - Environment variable template with RPC URLs
- `apps/web/.env.example` - Frontend environment variables for wagmi config
- `apps/api/tests/unit/services/RpcBatchManager.test.ts` - Unit tests
- `apps/api/tests/integration/rpc-failover.test.ts` - Integration tests
- `apps/api/tests/integration/health-check.test.ts` - E2E health check tests
- `apps/api/tests/fixtures/rpc-responses.ts` - Test fixtures and mock data
- `apps/api/vitest.config.ts` - Test configuration
- `apps/api/package.json` - API dependencies and scripts
- `packages/shared/package.json` - Shared package configuration
- `packages/web3/package.json` - Web3 package configuration

## QA Results
_To be populated by QA agent_