# Story 1.5: Multi-Chain RPC Infrastructure with Health Check

## Status
Draft

## Story
**As a** developer,
**I want** to implement efficient batched RPC calls with a working health check system,
**so that** I can validate RPC connectivity and establish the data fetching foundation.

## Acceptance Criteria
1. RPC provider configuration with Alchemy/Infura primary and fallback endpoints
2. Batched RPC call system with example batch operation (multiple eth_getBalance calls)
3. Redis caching layer for RPC responses with configurable TTL
4. Rate limiting protection with exponential backoff and queue management
5. Chain-specific error handling and failover mechanisms
6. Health check endpoint that tests RPC connectivity to all three chains

## Tasks / Subtasks
- [ ] Configure RPC Provider Infrastructure (AC: 1)
  - [ ] Set up Alchemy provider configuration for Ethereum, Arbitrum, and Avalanche
  - [ ] Configure Infura as fallback provider with proper authentication
  - [ ] Create provider configuration in `packages/web3/src/rpc/providers.ts`
  - [ ] Set up environment variables for API keys in `.env.example`
- [ ] Implement RPC Batch Manager Service (AC: 2)
  - [ ] Create `apps/api/src/services/RpcBatchManager.ts` service class
  - [ ] Implement `batchCall()` method for aggregating multiple RPC requests
  - [ ] Add example batch operation for multiple `eth_getBalance` calls
  - [ ] Ensure BigInt handling for all numeric blockchain values
- [ ] Set Up Redis Caching Layer (AC: 3)
  - [ ] Configure Redis client connection in `apps/api/src/db/redis.ts`
  - [ ] Implement cache key generation strategy for RPC responses
  - [ ] Add configurable TTL settings per cache type (balances: 30s, metadata: 1h)
  - [ ] Create `getCachedData()` and `setCachedData()` methods
- [ ] Implement Rate Limiting and Queue Management (AC: 4)
  - [ ] Add rate limiting middleware using `@fastify/rate-limit`
  - [ ] Implement exponential backoff retry logic in RPC Batch Manager
  - [ ] Create request queue with configurable concurrency limits
  - [ ] Add monitoring for rate limit violations and queue depth
- [ ] Build Chain-Specific Error Handling (AC: 5)
  - [ ] Create error classification system for RPC errors
  - [ ] Implement automatic failover from Alchemy to Infura on errors
  - [ ] Add chain-specific error recovery strategies
  - [ ] Log all provider switches and error patterns for monitoring
- [ ] Create Health Check Endpoint (AC: 6)
  - [ ] Implement `/health` endpoint in Fastify server
  - [ ] Add RPC connectivity tests for all three chains
  - [ ] Include Redis connection health check
  - [ ] Return detailed service status with response times
- [ ] Write Comprehensive Tests (Testing Requirements)
  - [ ] Unit tests for RPC Batch Manager service
  - [ ] Integration tests for provider failover scenarios
  - [ ] Tests for cache hit/miss scenarios
  - [ ] E2E test for health check endpoint
  - [ ] Performance tests for batch operations

## Dev Notes

### Previous Story Insights
From Story 1.2 completion:
- Wagmi v2 configuration is set up with chain definitions for Ethereum (1), Arbitrum (42161), and Avalanche (43114)
- Wallet connection infrastructure is established and can be leveraged for testing RPC calls
- Mock portfolio data structure is defined and can be replaced with real RPC data

### RPC Provider Configuration
[Source: architecture/external-apis.md#alchemy-api]
- **Alchemy API**: Primary RPC provider with 300 compute units/second (Growth tier)
- **Base URLs**: Chain-specific endpoints (eth-mainnet, arb-mainnet, avax-mainnet)
- **Authentication**: API Key in headers
- **Enhanced APIs**: Use `getTokenBalances` and `getTokenMetadata` for efficiency

[Source: architecture/external-apis.md#infura-api]
- **Infura API**: Fallback provider with 100,000 requests/day (Core tier)
- **Purpose**: Ensuring 99.5% uptime through provider redundancy
- **Authentication**: Project ID and secret

### Service Implementation Location
[Source: architecture/unified-project-structure.md#backend-organization]
- **RPC Batch Manager**: `apps/api/src/services/RpcBatchManager.ts`
- **Provider Adapters**: `apps/api/src/adapters/blockchain/AlchemyProvider.ts`, `InfuraProvider.ts`
- **Cache Client**: `apps/api/src/db/redis.ts`
- **Health Check**: Add to existing `apps/api/src/server.ts`

### Technology Stack Requirements
[Source: architecture/tech-stack.md#technology-stack-table]
- **Backend Framework**: Fastify 4.x for high-performance
- **Cache**: Redis 7.x via Redis Cloud for RPC response caching
- **Backend Language**: Node.js 20 LTS
- **Database**: PostgreSQL 15+ via Supabase for persistence

### RPC Batch Manager Component Specification
[Source: architecture/components.md#rpc-batch-manager]
**Key Interfaces**:
- `batchCall(requests: RPCRequest[]): Promise<RPCResponse[]>` - Execute batched RPC requests
- `getCachedData(key: string): Promise<CachedData | null>` - Retrieve cached blockchain data
- `invalidateCache(pattern: string): Promise<void>` - Cache invalidation for real-time updates

**Dependencies**: Redis Cache, RPC Providers (Alchemy/Infura), Chain Configuration Service

### Server Configuration Pattern
[Source: architecture/backend-architecture.md#server-template]
```typescript
// Health check endpoint pattern already defined in server.ts
server.get('/health', async (request, reply) => {
  const health = {
    status: 'healthy',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    services: {
      database: await checkDatabaseHealth(),
      redis: await checkRedisHealth(),
      rpc: await checkRpcHealth() // Add this new check
    }
  };
  // Return 200 if all healthy, 503 if any service is down
});
```

### Error Handling Strategy
[Source: architecture/external-apis.md#error-handling-fallback-strategy]
**RPC Provider Fallback Order**:
1. Primary: Alchemy API with enhanced features
2. Secondary: Infura API for redundancy
3. Tertiary: Additional providers as needed

### Coding Standards
[Source: architecture/coding-standards.md#critical-fullstack-rules]
- **BigInt Precision**: Always use BigInt for financial calculations, never JavaScript numbers
- **RPC Batching**: Group blockchain calls through RPC Batch Manager, never direct calls
- **Environment Variables**: Access only through config objects, never process.env directly
- **Error Handling**: All API routes must use the standard error handler

### Testing Requirements
[Source: architecture/testing-strategy.md#backend-tests]
**Test Organization**:
- Unit tests: `apps/api/tests/unit/services/RpcBatchManager.test.ts`
- Integration tests: `apps/api/tests/integration/rpc-failover.test.ts`
- Test fixtures: `apps/api/tests/fixtures/rpc-responses.ts`

**Testing Framework**: Vitest for all backend tests with Supertest for API testing

### Environment Variables Required
```bash
# RPC Providers
ALCHEMY_API_KEY=your_alchemy_key
INFURA_PROJECT_ID=your_infura_project_id
INFURA_PROJECT_SECRET=your_infura_secret

# Redis Configuration
REDIS_URL=redis://localhost:6379
REDIS_PASSWORD=optional_password

# Rate Limiting
RPC_RATE_LIMIT_MAX=100
RPC_RATE_LIMIT_WINDOW=60000
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-08 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes List
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_