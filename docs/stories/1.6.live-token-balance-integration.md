# Story 1.6: Live Token Balance Integration

## Status
Ready for Development

## Story
**As a** DeFi user,
**I want** to see my actual token balances across all chains replacing the mock data,
**so that** I can view my real portfolio instead of sample data.

## Acceptance Criteria
1. Replace mock token data with live balance fetching using batched RPC calls
2. Price data integration with Moralis API including fallback to DefiLlama and CoinMarketCap
3. USD value calculations with proper decimal handling and formatting
4. Token metadata resolution (name, symbol, decimals) with caching
5. Portfolio total value calculation and chain-wise breakdown display
6. Graceful fallback to "No tokens found" when wallet has no balances

## Tasks / Subtasks
- [ ] Implement Live Token Balance Fetching (AC: 1)
  - [ ] Create token balance detection service in `apps/api/src/services/TokenBalanceService.ts`
  - [ ] Integrate with existing RPC Batch Manager for multi-chain balance queries
  - [ ] Add support for ERC-20 token detection and native token balances
  - [ ] Implement batched balance calls for discovered tokens across Ethereum, Arbitrum, and Avalanche
- [ ] Integrate Price Data Service (AC: 2)
  - [ ] Create PriceService in `apps/api/src/services/PriceService.ts` with Moralis primary, DefiLlama secondary, and CoinMarketCap tertiary fallback
  - [ ] Add token price fetching with batch requests to minimize API calls
  - [ ] Implement price caching with 15-second TTL for real-time updates
  - [ ] Add price data fallback strategy for tokens not found in primary sources
- [ ] Build USD Value Calculation System (AC: 3)
  - [ ] Create value calculation utilities in `packages/shared/src/utils/format.ts`
  - [ ] Implement BigInt-based calculations for financial precision
  - [ ] Add proper decimal handling for different token precisions
  - [ ] Create currency formatting utilities with extreme value support
- [ ] Implement Token Metadata Resolution (AC: 4)
  - [ ] Create token metadata service with Alchemy enhanced API integration
  - [ ] Add metadata caching layer with 1-hour TTL for token details
  - [ ] Implement fallback to on-chain metadata queries when API unavailable
  - [ ] Create token metadata types and validation schemas
- [ ] Create Portfolio Aggregation System (AC: 5)
  - [ ] Build PortfolioAggregator service in `apps/api/src/services/PortfolioAggregator.ts`
  - [ ] Implement total value calculation across all chains and tokens
  - [ ] Add chain-wise breakdown calculation with proper aggregation
  - [ ] Create portfolio composition analysis by asset categories
- [ ] Update Frontend Components (AC: 6)
  - [ ] Replace mock data in PortfolioOverview component with real tRPC calls
  - [ ] Add loading states and skeleton components during data fetching
  - [ ] Implement error handling with graceful "No tokens found" fallback
  - [ ] Add refresh functionality with optimistic updates
- [ ] Write Comprehensive Tests (Testing Requirements)
  - [ ] Unit tests for TokenBalanceService and PriceService
  - [ ] Integration tests for portfolio aggregation workflow
  - [ ] Frontend component tests with mock API responses
  - [ ] E2E tests for complete portfolio loading flow

## Dev Notes

### Previous Story Insights
From Story 1.5 completion:
- RPC Batch Manager is fully implemented with Alchemy/Infura failover and caching
- Redis caching system is configured with proper TTL settings
- Enhanced error handling and rate limiting are in place
- Health check endpoint is operational for monitoring RPC connectivity
- File locations: RPC infrastructure in `apps/api/src/services/`, caching in `apps/api/src/db/redis.ts`

### Data Models
[Source: architecture/data-models.md#tokenbalance]
**TokenBalance Interface**:
```typescript
interface TokenBalance {
  id: string;
  portfolioId: string;
  tokenAddress: string;
  balance: bigint;
  metadata: TokenMetadata;
  priceUSD: bigint;
  valueUSD: bigint;
  category: AssetCategory;
  lastUpdatedAt: Date;
}

interface TokenMetadata {
  name: string;
  symbol: string;
  decimals: number;
  logoURI?: string;
  coingeckoId?: string;
}
```

[Source: architecture/data-models.md#portfolio]
**Portfolio Interface**:
```typescript
interface Portfolio {
  id: string;
  userId: string;
  chainId: number;
  totalValue: bigint;
  healthScore: number;
  lastSyncedAt: Date;
  composition: AssetComposition[];
  tokens: TokenBalance[];
  lpPositions: LPPosition[];
}
```

### API Specifications
[Source: architecture/api-specification.md#portfolio-router]
**tRPC Portfolio Router**:
- `getPortfolio({ userId, chains })` - Returns Portfolio[] with all positions and balances
- `refreshPortfolio({ userId, chainId, forceRefresh })` - Triggers RPC batching and cache updates
- Input validation with Zod schemas including BigInt handling

### Component Specifications
[Source: architecture/components.md#portfolio-data-aggregator]
**Portfolio Data Aggregator**:
- `aggregatePortfolio(userId: string, chains: number[]): Promise<Portfolio[]>` - Collect complete portfolio data
- `syncPortfolioData(portfolioId: string): Promise<SyncResult>` - Sync with blockchain state
- Dependencies: RPC Batch Manager, Token Price Service, Health Score Calculator

### File Locations
[Source: architecture/unified-project-structure.md#backend-organization]
- **TokenBalanceService**: `apps/api/src/services/TokenBalanceService.ts`
- **PriceService**: `apps/api/src/services/PriceService.ts`
- **PortfolioAggregator**: `apps/api/src/services/PortfolioAggregator.ts`
- **Shared utilities**: `packages/shared/src/utils/format.ts`
- **Portfolio types**: `packages/shared/src/types/portfolio.ts`
- **Frontend components**: `apps/web/src/components/portfolio/PortfolioOverview.tsx`

### Technology Stack Requirements
[Source: architecture/tech-stack.md#technology-stack-table]
- **Backend Framework**: Fastify 4.x for high-performance API endpoints
- **State Management**: TanStack Query v5 + Zustand v4 for server/client state
- **API Style**: tRPC v10 for type-safe portfolio data fetching
- **Cache**: Redis 7.x for price data caching (15s TTL) and token metadata (1h TTL)

### External API Integration
[Source: architecture/external-apis.md#cost-optimized-price-data-strategy]
**Price Data Strategy**:
- **Primary**: Moralis Web3 API ($49/month, 25M requests) - Web3-native with excellent rate limits
- **Secondary**: DefiLlama (Free) - DeFi-specialized with unlimited requests
- **Tertiary**: CoinMarketCap Basic ($29/month, 10K daily) - Reliable premium fallback

[Source: architecture/external-apis.md#alchemy-api]
**Alchemy Enhanced APIs**:
- `getTokenBalances` endpoint for efficient multi-token balance queries
- `getTokenMetadata` endpoint for token name, symbol, decimals resolution
- 300 compute units/second rate limits with automatic failover to Infura

### Coding Standards
[Source: architecture/coding-standards.md#critical-fullstack-rules]
- **BigInt Precision**: Always use BigInt for financial calculations, never JavaScript numbers
- **Price Formatting**: Use shared formatting utilities to handle extreme token values
- **RPC Batching**: Group blockchain calls through RPC Batch Manager, never direct calls
- **Type Sharing**: Define types in packages/shared and import from there
- **Environment Variables**: Access only through config objects, never process.env directly

### Frontend Architecture
[Source: architecture/frontend-architecture.md#state-management-patterns]
**State Management**:
- **Server State**: TanStack Query handles portfolio data with 30s stale time and smart refresh intervals
- **Client State**: Zustand manages dashboard layout and preferences
- **Optimistic Updates**: Refresh mutations with rollback on error
- **Error Handling**: Exponential backoff for RPC failures, single retry for other errors

[Source: architecture/frontend-architecture.md#component-template]
**Component Patterns**:
```typescript
// Portfolio hook with parallel data fetching
export function usePortfolio(options?: {
  refreshInterval?: number;
  includeHealthAnalysis?: boolean;
}) {
  const { address } = useAccount();
  const { selectedChains } = useDashboardStore();
  
  const portfolioQuery = trpc.portfolio.getPortfolio.useQuery(
    {
      walletAddress: address!,
      chainIds: selectedChains
    },
    {
      enabled: !!address,
      refetchInterval: options?.refreshInterval ?? 30000,
      staleTime: 15000
    }
  );
}
```

### Environment Variables Required
```bash
# Price Data APIs
MORALIS_API_KEY=your_moralis_key      # Primary price data source
COINMARKETCAP_API_KEY=your_cmc_key    # Tertiary fallback tier

# Existing RPC and Redis configuration from Story 1.5
ALCHEMY_API_KEY=already_configured
INFURA_PROJECT_ID=already_configured
REDIS_URL=already_configured
```

## Testing
[Source: architecture/testing-strategy.md#test-organization]

**Test File Locations**:
- Unit tests: `apps/api/tests/unit/services/TokenBalanceService.test.ts`
- Unit tests: `apps/api/tests/unit/services/PriceService.test.ts` 
- Unit tests: `apps/api/tests/unit/services/PortfolioAggregator.test.ts`
- Integration tests: `apps/api/tests/integration/portfolio-aggregation.test.ts`
- Frontend tests: `apps/web/tests/components/PortfolioOverview.test.tsx`
- E2E tests: `apps/web/tests/e2e/portfolio-loading.spec.ts`

**Testing Framework**: Vitest for all backend and frontend unit tests, Supertest for API integration testing, Testing Library for React component testing, Playwright for E2E testing

**Test Requirements**:
- Mock RPC responses for different wallet states (empty, single token, multiple tokens)
- Mock price API responses with fallback scenarios
- Test BigInt calculations and currency formatting edge cases
- Verify proper error handling and fallback displays
- Test caching behavior and cache invalidation

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-08 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
*To be populated by development agent*

### Debug Log References
*To be populated by development agent during implementation*

### Completion Notes List
*To be populated by development agent upon story completion*

### File List
*To be populated by development agent with all created/modified files*

## QA Results
*To be populated by QA agent upon story review*